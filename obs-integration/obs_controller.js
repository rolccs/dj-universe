// Controlador OBS para streaming autom√°tico a plataformas (Twitch, YouTube, Facebook)
// Basado en reverse engineering de OBS Studio y obs-websocket

const OBSWebSocket = require('obs-websocket-js').default;
const EventEmitter = require('events');
const fs = require('fs').promises;
const path = require('path');

class OBSController extends EventEmitter {
    constructor(config = {}) {\n        super();\n        \n        this.config = {\n            obsWebSocketUrl: config.obsWebSocketUrl || 'ws://localhost:4455',\n            obsWebSocketPassword: config.obsWebSocketPassword || '',\n            scenePrefix: config.scenePrefix || 'DJ-Battle',\n            recordingsPath: config.recordingsPath || './recordings',\n            streamingPlatforms: config.streamingPlatforms || [],\n            autoSwitchScenes: config.autoSwitchScenes || true,\n            autoStartRecording: config.autoStartRecording || true,\n            ...config\n        };\n        \n        this.obs = new OBSWebSocket();\n        this.isConnected = false;\n        this.currentBattle = null;\n        this.scenes = new Map();\n        this.sources = new Map();\n        this.filters = new Map();\n        \n        this.battlePhases = {\n            'waiting': 'Waiting Room',\n            'preparation': 'DJ Preparation',\n            'battle-round-1': 'Battle Round 1',\n            'battle-round-2': 'Battle Round 2',\n            'voting': 'Audience Voting',\n            'results': 'Battle Results',\n            'celebration': 'Winner Celebration'\n        };\n        \n        this.initialize();\n    }\n    \n    async initialize() {\n        try {\n            console.log('üé• Initializing OBS Controller...');\n            \n            await this.connectToOBS();\n            await this.setupEventListeners();\n            await this.createBattleScenes();\n            await this.setupSources();\n            await this.setupFilters();\n            \n            console.log('‚úÖ OBS Controller initialized successfully');\n            this.emit('ready');\n            \n        } catch (error) {\n            console.error('‚ùå Failed to initialize OBS Controller:', error);\n            this.emit('error', error);\n        }\n    }\n    \n    async connectToOBS() {\n        try {\n            await this.obs.connect(this.config.obsWebSocketUrl, this.config.obsWebSocketPassword);\n            this.isConnected = true;\n            console.log('‚úÖ Connected to OBS WebSocket');\n            \n            // Obtener informaci√≥n de versi√≥n\n            const version = await this.obs.call('GetVersion');\n            console.log(`üì± OBS Studio Version: ${version.obsVersion}`);\n            \n        } catch (error) {\n            console.error('‚ùå Failed to connect to OBS:', error);\n            throw error;\n        }\n    }\n    \n    setupEventListeners() {\n        // Eventos de OBS\n        this.obs.on('ConnectionClosed', () => {\n            console.log('üîå OBS connection closed');\n            this.isConnected = false;\n            this.emit('disconnected');\n        });\n        \n        this.obs.on('SceneTransitionStarted', (data) => {\n            console.log(`üé¨ Scene transition started: ${data.transitionName}`);\n            this.emit('scene-transition-started', data);\n        });\n        \n        this.obs.on('SceneTransitionEnded', (data) => {\n            console.log(`üé¨ Scene transition ended: ${data.sceneName}`);\n            this.emit('scene-transition-ended', data);\n        });\n        \n        this.obs.on('StreamStateChanged', (data) => {\n            console.log(`üì° Stream state changed: ${data.outputState}`);\n            this.emit('stream-state-changed', data);\n        });\n        \n        this.obs.on('RecordStateChanged', (data) => {\n            console.log(`üî¥ Recording state changed: ${data.outputState}`);\n            this.emit('record-state-changed', data);\n        });\n    }\n    \n    async createBattleScenes() {\n        console.log('üé¨ Creating battle scenes...');\n        \n        const sceneConfigs = [\n            {\n                name: `${this.config.scenePrefix}-Waiting`,\n                description: 'Sala de espera antes de la batalla',\n                layout: 'waiting-room'\n            },\n            {\n                name: `${this.config.scenePrefix}-Preparation`,\n                description: 'Preparaci√≥n de DJs',\n                layout: 'split-screen'\n            },\n            {\n                name: `${this.config.scenePrefix}-Battle`,\n                description: 'Batalla principal',\n                layout: 'battle-view'\n            },\n            {\n                name: `${this.config.scenePrefix}-Voting`,\n                description: 'Fase de votaci√≥n',\n                layout: 'voting-overlay'\n            },\n            {\n                name: `${this.config.scenePrefix}-Results`,\n                description: 'Resultados y ganador',\n                layout: 'results-screen'\n            }\n        ];\n        \n        for (const sceneConfig of sceneConfigs) {\n            try {\n                // Verificar si la escena ya existe\n                const existingScenes = await this.obs.call('GetSceneList');\n                const sceneExists = existingScenes.scenes.some(scene => scene.sceneName === sceneConfig.name);\n                \n                if (!sceneExists) {\n                    await this.obs.call('CreateScene', {\n                        sceneName: sceneConfig.name\n                    });\n                    console.log(`‚úÖ Created scene: ${sceneConfig.name}`);\n                }\n                \n                this.scenes.set(sceneConfig.layout, sceneConfig.name);\n                \n            } catch (error) {\n                console.error(`‚ùå Failed to create scene ${sceneConfig.name}:`, error);\n            }\n        }\n    }\n    \n    async setupSources() {\n        console.log('üé• Setting up video sources...');\n        \n        const sourceConfigs = [\n            {\n                sourceName: 'DJ1-Camera',\n                sourceKind: 'v4l2_input', // Linux camera\n                settings: {\n                    device_id: '/dev/video0',\n                    resolution: '1920x1080',\n                    framerate: '30'\n                }\n            },\n            {\n                sourceName: 'DJ2-Camera',\n                sourceKind: 'v4l2_input',\n                settings: {\n                    device_id: '/dev/video1',\n                    resolution: '1920x1080',\n                    framerate: '30'\n                }\n            },\n            {\n                sourceName: 'DJ-Universe-NDI',\n                sourceKind: 'ndi_source',\n                settings: {\n                    ndi_name: 'DJ-Universe-Battle',\n                    sync: true,\n                    hw_decode: true,\n                    low_latency: true\n                }\n            },\n            {\n                sourceName: 'Battle-Audio-Mix',\n                sourceKind: 'pulse_input_capture', // Linux audio\n                settings: {\n                    device_id: 'alsa_output.usb-mixer.analog-stereo.monitor'\n                }\n            },\n            {\n                sourceName: 'Overlay-Graphics',\n                sourceKind: 'browser_source',\n                settings: {\n                    url: 'http://localhost:3000/overlay',\n                    width: 1920,\n                    height: 1080,\n                    fps: 30\n                }\n            },\n            {\n                sourceName: 'Battle-Timer',\n                sourceKind: 'text_gdiplus',\n                settings: {\n                    text: '00:00',\n                    font: {\n                        family: 'Arial',\n                        size: 48,\n                        flags: 1 // Bold\n                    },\n                    color: 0xFFFFFF\n                }\n            }\n        ];\n        \n        for (const sourceConfig of sourceConfigs) {\n            try {\n                await this.createSource(sourceConfig);\n                this.sources.set(sourceConfig.sourceName, sourceConfig);\n            } catch (error) {\n                console.error(`‚ùå Failed to create source ${sourceConfig.sourceName}:`, error);\n            }\n        }\n    }\n    \n    async createSource(sourceConfig) {\n        try {\n            // Verificar si la fuente ya existe\n            const sources = await this.obs.call('GetInputList');\n            const sourceExists = sources.inputs.some(source => source.inputName === sourceConfig.sourceName);\n            \n            if (!sourceExists) {\n                await this.obs.call('CreateInput', {\n                    sceneName: `${this.config.scenePrefix}-Battle`,\n                    inputName: sourceConfig.sourceName,\n                    inputKind: sourceConfig.sourceKind,\n                    inputSettings: sourceConfig.settings\n                });\n                \n                console.log(`‚úÖ Created source: ${sourceConfig.sourceName}`);\n            }\n        } catch (error) {\n            console.error(`‚ùå Error creating source ${sourceConfig.sourceName}:`, error);\n        }\n    }\n    \n    async setupFilters() {\n        console.log('üé® Setting up audio/video filters...');\n        \n        const filterConfigs = [\n            {\n                sourceName: 'DJ1-Camera',\n                filterName: 'Color Correction',\n                filterKind: 'color_filter',\n                settings: {\n                    brightness: 0.1,\n                    contrast: 0.1,\n                    saturation: 0.05\n                }\n            },\n            {\n                sourceName: 'DJ2-Camera',\n                filterName: 'Color Correction',\n                filterKind: 'color_filter',\n                settings: {\n                    brightness: 0.1,\n                    contrast: 0.1,\n                    saturation: 0.05\n                }\n            },\n            {\n                sourceName: 'Battle-Audio-Mix',\n                filterName: 'Compressor',\n                filterKind: 'compressor_filter',\n                settings: {\n                    ratio: 4.0,\n                    threshold: -20.0,\n                    attack_time: 6,\n                    release_time: 60\n                }\n            },\n            {\n                sourceName: 'Battle-Audio-Mix',\n                filterName: 'Noise Gate',\n                filterKind: 'noise_gate_filter',\n                settings: {\n                    close_threshold: -50.0,\n                    open_threshold: -45.0,\n                    attack_time: 25,\n                    hold_time: 200,\n                    release_time: 150\n                }\n            }\n        ];\n        \n        for (const filterConfig of filterConfigs) {\n            try {\n                await this.createFilter(filterConfig);\n                \n                const filterKey = `${filterConfig.sourceName}-${filterConfig.filterName}`;\n                this.filters.set(filterKey, filterConfig);\n                \n            } catch (error) {\n                console.error(`‚ùå Failed to create filter ${filterConfig.filterName}:`, error);\n            }\n        }\n    }\n    \n    async createFilter(filterConfig) {\n        try {\n            await this.obs.call('CreateSourceFilter', {\n                sourceName: filterConfig.sourceName,\n                filterName: filterConfig.filterName,\n                filterKind: filterConfig.filterKind,\n                filterSettings: filterConfig.settings\n            });\n            \n            console.log(`‚úÖ Created filter: ${filterConfig.filterName} for ${filterConfig.sourceName}`);\n            \n        } catch (error) {\n            // Filter might already exist\n            if (!error.message.includes('already exists')) {\n                throw error;\n            }\n        }\n    }\n    \n    // Control de batalla\n    \n    async startBattle(battleData) {\n        console.log(`‚öîÔ∏è Starting battle: ${battleData.id}`);\n        \n        this.currentBattle = battleData;\n        \n        try {\n            // Configurar escenas con informaci√≥n de la batalla\n            await this.updateBattleOverlays(battleData);\n            \n            // Cambiar a escena de preparaci√≥n\n            await this.switchToScene('split-screen');\n            \n            // Iniciar grabaci√≥n si est√° habilitado\n            if (this.config.autoStartRecording) {\n                await this.startRecording(battleData.id);\n            }\n            \n            // Configurar streaming si hay plataformas configuradas\n            if (this.config.streamingPlatforms.length > 0) {\n                await this.startStreaming();\n            }\n            \n            this.emit('battle-started', battleData);\n            \n        } catch (error) {\n            console.error('‚ùå Failed to start battle:', error);\n            this.emit('error', error);\n        }\n    }\n    \n    async updateBattleOverlays(battleData) {\n        // Actualizar texto de informaci√≥n de la batalla\n        await this.updateTextSource('Battle-Info', {\n            text: `${battleData.title}\\n${battleData.dj1.name} vs ${battleData.dj2.name}`,\n            font: { size: 32 }\n        });\n        \n        // Actualizar navegador con overlay din√°mico\n        await this.updateBrowserSource('Overlay-Graphics', {\n            url: `http://localhost:3000/overlay?battleId=${battleData.id}`\n        });\n    }\n    \n    async switchPhase(phase) {\n        if (!this.currentBattle) {\n            console.warn('‚ö†Ô∏è No active battle to switch phase');\n            return;\n        }\n        \n        console.log(`üîÑ Switching to phase: ${phase}`);\n        \n        const sceneMap = {\n            'waiting': 'waiting-room',\n            'preparation': 'split-screen',\n            'battle-round-1': 'battle-view',\n            'battle-round-2': 'battle-view',\n            'voting': 'voting-overlay',\n            'results': 'results-screen'\n        };\n        \n        const sceneName = sceneMap[phase];\n        if (sceneName) {\n            await this.switchToScene(sceneName);\n            \n            // Configuraciones espec√≠ficas por fase\n            switch (phase) {\n                case 'battle-round-1':\n                    await this.startBattleTimer(180); // 3 minutos\n                    break;\n                    \n                case 'battle-round-2':\n                    await this.startBattleTimer(180);\n                    break;\n                    \n                case 'voting':\n                    await this.showVotingOverlay();\n                    break;\n                    \n                case 'results':\n                    await this.showResults();\n                    break;\n            }\n            \n            this.emit('phase-switched', { phase, sceneName });\n        }\n    }\n    \n    async switchToScene(sceneLayout) {\n        const sceneName = this.scenes.get(sceneLayout);\n        if (sceneName) {\n            await this.obs.call('SetCurrentProgramScene', {\n                sceneName: sceneName\n            });\n            console.log(`üé¨ Switched to scene: ${sceneName}`);\n        }\n    }\n    \n    async startBattleTimer(seconds) {\n        console.log(`‚è±Ô∏è Starting battle timer: ${seconds} seconds`);\n        \n        let remaining = seconds;\n        \n        const timerInterval = setInterval(async () => {\n            const minutes = Math.floor(remaining / 60);\n            const secs = remaining % 60;\n            const timeText = `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n            \n            await this.updateTextSource('Battle-Timer', {\n                text: timeText,\n                color: remaining <= 30 ? 0xFF0000 : 0xFFFFFF // Rojo en √∫ltimos 30 segundos\n            });\n            \n            remaining--;\n            \n            if (remaining < 0) {\n                clearInterval(timerInterval);\n                await this.updateTextSource('Battle-Timer', {\n                    text: 'TIME!',\n                    color: 0xFF0000\n                });\n                this.emit('timer-ended');\n            }\n        }, 1000);\n        \n        return timerInterval;\n    }\n    \n    async showVotingOverlay() {\n        console.log('üó≥Ô∏è Showing voting overlay');\n        \n        await this.updateBrowserSource('Overlay-Graphics', {\n            url: `http://localhost:3000/voting?battleId=${this.currentBattle.id}`\n        });\n    }\n    \n    async showResults() {\n        console.log('üèÜ Showing battle results');\n        \n        await this.updateBrowserSource('Overlay-Graphics', {\n            url: `http://localhost:3000/results?battleId=${this.currentBattle.id}`\n        });\n    }\n    \n    // Utilidades para fuentes\n    \n    async updateTextSource(sourceName, settings) {\n        try {\n            await this.obs.call('SetInputSettings', {\n                inputName: sourceName,\n                inputSettings: settings\n            });\n        } catch (error) {\n            console.error(`‚ùå Failed to update text source ${sourceName}:`, error);\n        }\n    }\n    \n    async updateBrowserSource(sourceName, settings) {\n        try {\n            await this.obs.call('SetInputSettings', {\n                inputName: sourceName,\n                inputSettings: settings\n            });\n        } catch (error) {\n            console.error(`‚ùå Failed to update browser source ${sourceName}:`, error);\n        }\n    }\n    \n    // Grabaci√≥n y streaming\n    \n    async startRecording(battleId) {\n        try {\n            const filename = `battle-${battleId}-${Date.now()}.mp4`;\n            const filepath = path.join(this.config.recordingsPath, filename);\n            \n            await this.obs.call('SetRecordDirectory', {\n                recordDirectory: this.config.recordingsPath\n            });\n            \n            await this.obs.call('StartRecord');\n            \n            console.log(`üî¥ Recording started: ${filename}`);\n            this.emit('recording-started', { battleId, filename, filepath });\n            \n        } catch (error) {\n            console.error('‚ùå Failed to start recording:', error);\n        }\n    }\n    \n    async stopRecording() {\n        try {\n            await this.obs.call('StopRecord');\n            console.log('‚èπÔ∏è Recording stopped');\n            this.emit('recording-stopped');\n        } catch (error) {\n            console.error('‚ùå Failed to stop recording:', error);\n        }\n    }\n    \n    async startStreaming() {\n        try {\n            await this.obs.call('StartStream');\n            console.log('üì° Streaming started');\n            this.emit('streaming-started');\n        } catch (error) {\n            console.error('‚ùå Failed to start streaming:', error);\n        }\n    }\n    \n    async stopStreaming() {\n        try {\n            await this.obs.call('StopStream');\n            console.log('üì° Streaming stopped');\n            this.emit('streaming-stopped');\n        } catch (error) {\n            console.error('‚ùå Failed to stop streaming:', error);\n        }\n    }\n    \n    async endBattle() {\n        if (!this.currentBattle) {\n            return;\n        }\n        \n        console.log(`‚öîÔ∏è Ending battle: ${this.currentBattle.id}`);\n        \n        try {\n            // Detener grabaci√≥n\n            await this.stopRecording();\n            \n            // Cambiar a escena de resultados\n            await this.switchToScene('results-screen');\n            \n            // Esperar antes de limpiar\n            setTimeout(async () => {\n                await this.switchToScene('waiting-room');\n                this.currentBattle = null;\n            }, 30000); // 30 segundos\n            \n            this.emit('battle-ended');\n            \n        } catch (error) {\n            console.error('‚ùå Failed to end battle properly:', error);\n        }\n    }\n    \n    // Estado y utilidades\n    \n    async getStatus() {\n        if (!this.isConnected) {\n            return { connected: false };\n        }\n        \n        try {\n            const streamStatus = await this.obs.call('GetStreamStatus');\n            const recordStatus = await this.obs.call('GetRecordStatus');\n            const currentScene = await this.obs.call('GetCurrentProgramScene');\n            \n            return {\n                connected: true,\n                streaming: streamStatus.outputActive,\n                recording: recordStatus.outputActive,\n                currentScene: currentScene.currentProgramSceneName,\n                currentBattle: this.currentBattle?.id || null\n            };\n        } catch (error) {\n            console.error('‚ùå Failed to get OBS status:', error);\n            return { connected: true, error: error.message };\n        }\n    }\n    \n    async disconnect() {\n        if (this.obs) {\n            await this.obs.disconnect();\n            this.isConnected = false;\n            console.log('üîå Disconnected from OBS');\n        }\n    }\n}\n\nmodule.exports = OBSController;"