// Node.js bindings para el analizador de espectro en tiempo real
// Permite usar el analizador desde JavaScript/TypeScript

#include <napi.h>
#include "real_time_analyzer.cpp"
#include <memory>
#include <thread>

using namespace DJUniverse;

class SpectrumAnalyzerWrapper : public Napi::ObjectWrap<SpectrumAnalyzerWrapper> {
public:
    static Napi::Object Init(Napi::Env env, Napi::Object exports) {
        Napi::Function func = DefineClass(env, "SpectrumAnalyzer", {
            InstanceMethod("start", &SpectrumAnalyzerWrapper::Start),
            InstanceMethod("stop", &SpectrumAnalyzerWrapper::Stop),
            InstanceMethod("processAudio", &SpectrumAnalyzerWrapper::ProcessAudio),\n            InstanceMethod("getLatestSpectrum", &SpectrumAnalyzerWrapper::GetLatestSpectrum),\n            InstanceMethod("getLatestBeatDetection", &SpectrumAnalyzerWrapper::GetLatestBeatDetection),\n            InstanceMethod("analyzeFrequencyBands", &SpectrumAnalyzerWrapper::AnalyzeFrequencyBands),\n            InstanceMethod("detectMusicalKey", &SpectrumAnalyzerWrapper::DetectMusicalKey),\n            InstanceMethod("analyzeTempoStability", &SpectrumAnalyzerWrapper::AnalyzeTempoStability),\n        });\n        \n        Napi::FunctionReference* constructor = new Napi::FunctionReference();\n        *constructor = Napi::Persistent(func);\n        env.SetInstanceData(constructor);\n        \n        exports.Set(\"SpectrumAnalyzer\", func);\n        return exports;\n    }\n    \n    SpectrumAnalyzerWrapper(const Napi::CallbackInfo& info) \n        : Napi::ObjectWrap<SpectrumAnalyzerWrapper>(info) {\n        \n        Napi::Env env = info.Env();\n        \n        // Parámetros opcionales\n        int sampleRate = 44100;\n        int fftSize = 2048;\n        int hopSize = 512;\n        \n        if (info.Length() >= 1 && info[0].IsObject()) {\n            Napi::Object config = info[0].As<Napi::Object>();\n            \n            if (config.Has(\"sampleRate\")) {\n                sampleRate = config.Get(\"sampleRate\").As<Napi::Number>().Int32Value();\n            }\n            if (config.Has(\"fftSize\")) {\n                fftSize = config.Get(\"fftSize\").As<Napi::Number>().Int32Value();\n            }\n            if (config.Has(\"hopSize\")) {\n                hopSize = config.Get(\"hopSize\").As<Napi::Number>().Int32Value();\n            }\n        }\n        \n        analyzer_ = std::make_unique<RealTimeSpectrumAnalyzer>(sampleRate, fftSize, hopSize);\n        \n        if (!analyzer_->initialize()) {\n            Napi::Error::New(env, \"Failed to initialize spectrum analyzer\").ThrowAsJavaScriptException();\n        }\n    }\n\nprivate:\n    std::unique_ptr<RealTimeSpectrumAnalyzer> analyzer_;\n    std::vector<SpectrumFrame> spectrumHistory_;\n    std::vector<BeatDetectionResult> beatHistory_;\n    \n    Napi::Value Start(const Napi::CallbackInfo& info) {\n        Napi::Env env = info.Env();\n        \n        analyzer_->start();\n        \n        return Napi::Boolean::New(env, true);\n    }\n    \n    Napi::Value Stop(const Napi::CallbackInfo& info) {\n        Napi::Env env = info.Env();\n        \n        analyzer_->stop();\n        \n        return Napi::Boolean::New(env, true);\n    }\n    \n    Napi::Value ProcessAudio(const Napi::CallbackInfo& info) {\n        Napi::Env env = info.Env();\n        \n        if (info.Length() < 1 || !info[0].IsTypedArray()) {\n            Napi::TypeError::New(env, \"Expected Float32Array\").ThrowAsJavaScriptException();\n            return env.Null();\n        }\n        \n        Napi::Float32Array audioArray = info[0].As<Napi::Float32Array>();\n        \n        analyzer_->processAudio(audioArray.Data(), audioArray.ElementLength());\n        \n        return Napi::Boolean::New(env, true);\n    }\n    \n    Napi::Value GetLatestSpectrum(const Napi::CallbackInfo& info) {\n        Napi::Env env = info.Env();\n        \n        SpectrumFrame frame;\n        bool hasData = analyzer_->getLatestSpectrum(frame);\n        \n        if (!hasData) {\n            return env.Null();\n        }\n        \n        // Agregar al historial\n        spectrumHistory_.push_back(frame);\n        if (spectrumHistory_.size() > 1000) {\n            spectrumHistory_.erase(spectrumHistory_.begin());\n        }\n        \n        // Convertir a objeto JavaScript\n        Napi::Object result = Napi::Object::New(env);\n        \n        // Magnitudes\n        Napi::Float32Array magnitudes = Napi::Float32Array::New(env, frame.magnitudes.size());\n        for (size_t i = 0; i < frame.magnitudes.size(); ++i) {\n            magnitudes[i] = frame.magnitudes[i];\n        }\n        result.Set(\"magnitudes\", magnitudes);\n        \n        // Fases\n        Napi::Float32Array phases = Napi::Float32Array::New(env, frame.phases.size());\n        for (size_t i = 0; i < frame.phases.size(); ++i) {\n            phases[i] = frame.phases[i];\n        }\n        result.Set(\"phases\", phases);\n        \n        // Frecuencias\n        Napi::Float32Array frequencies = Napi::Float32Array::New(env, frame.frequencies.size());\n        for (size_t i = 0; i < frame.frequencies.size(); ++i) {\n            frequencies[i] = frame.frequencies[i];\n        }\n        result.Set(\"frequencies\", frequencies);\n        \n        // Metadatos\n        result.Set(\"timestamp\", Napi::Number::New(env, frame.timestamp));\n        result.Set(\"peakFrequency\", Napi::Number::New(env, frame.peakFrequency));\n        result.Set(\"spectralCentroid\", Napi::Number::New(env, frame.spectralCentroid));\n        result.Set(\"spectralRolloff\", Napi::Number::New(env, frame.spectralRolloff));\n        result.Set(\"spectralFlux\", Napi::Number::New(env, frame.spectralFlux));\n        result.Set(\"rms\", Napi::Number::New(env, frame.rms));\n        result.Set(\"isValid\", Napi::Boolean::New(env, frame.isValid));\n        \n        return result;\n    }\n    \n    Napi::Value GetLatestBeatDetection(const Napi::CallbackInfo& info) {\n        Napi::Env env = info.Env();\n        \n        BeatDetectionResult beat;\n        bool hasData = analyzer_->getLatestBeatDetection(beat);\n        \n        if (!hasData) {\n            return env.Null();\n        }\n        \n        // Agregar al historial\n        beatHistory_.push_back(beat);\n        if (beatHistory_.size() > 500) {\n            beatHistory_.erase(beatHistory_.begin());\n        }\n        \n        Napi::Object result = Napi::Object::New(env);\n        result.Set(\"beatDetected\", Napi::Boolean::New(env, beat.beatDetected));\n        result.Set(\"confidence\", Napi::Number::New(env, beat.confidence));\n        result.Set(\"bpm\", Napi::Number::New(env, beat.bpm));\n        result.Set(\"beatStrength\", Napi::Number::New(env, beat.beatStrength));\n        \n        // Onset times\n        Napi::Array onsetTimes = Napi::Array::New(env, beat.onsetTimes.size());\n        for (size_t i = 0; i < beat.onsetTimes.size(); ++i) {\n            onsetTimes[i] = Napi::Number::New(env, beat.onsetTimes[i]);\n        }\n        result.Set(\"onsetTimes\", onsetTimes);\n        \n        return result;\n    }\n    \n    Napi::Value AnalyzeFrequencyBands(const Napi::CallbackInfo& info) {\n        Napi::Env env = info.Env();\n        \n        if (spectrumHistory_.empty()) {\n            return env.Null();\n        }\n        \n        // Usar el último frame\n        const SpectrumFrame& frame = spectrumHistory_.back();\n        FrequencyBands bands = analyzer_->analyzeFrequencyBands(frame);\n        \n        Napi::Object result = Napi::Object::New(env);\n        result.Set(\"subBass\", Napi::Number::New(env, bands.sub_bass));\n        result.Set(\"bass\", Napi::Number::New(env, bands.bass));\n        result.Set(\"lowMids\", Napi::Number::New(env, bands.low_mids));\n        result.Set(\"mids\", Napi::Number::New(env, bands.mids));\n        result.Set(\"highMids\", Napi::Number::New(env, bands.high_mids));\n        result.Set(\"presence\", Napi::Number::New(env, bands.presence));\n        result.Set(\"brilliance\", Napi::Number::New(env, bands.brilliance));\n        \n        return result;\n    }\n    \n    Napi::Value DetectMusicalKey(const Napi::CallbackInfo& info) {\n        Napi::Env env = info.Env();\n        \n        if (spectrumHistory_.size() < 10) {\n            return Napi::String::New(env, \"Unknown\");\n        }\n        \n        // Usar últimos 50 frames para análisis de clave\n        std::vector<SpectrumFrame> recentFrames;\n        size_t startIdx = spectrumHistory_.size() > 50 ? spectrumHistory_.size() - 50 : 0;\n        \n        for (size_t i = startIdx; i < spectrumHistory_.size(); ++i) {\n            recentFrames.push_back(spectrumHistory_[i]);\n        }\n        \n        std::string key = analyzer_->detectMusicalKey(recentFrames);\n        \n        return Napi::String::New(env, key);\n    }\n    \n    Napi::Value AnalyzeTempoStability(const Napi::CallbackInfo& info) {\n        Napi::Env env = info.Env();\n        \n        if (beatHistory_.size() < 10) {\n            return Napi::Number::New(env, 0.0);\n        }\n        \n        double stability = analyzer_->analyzeTempoStability(beatHistory_);\n        \n        return Napi::Number::New(env, stability);\n    }\n};\n\n// Funciones auxiliares exportadas\n\nNapi::Value CreateSpectrumVisualizer(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    \n    if (info.Length() < 1 || !info[0].IsObject()) {\n        Napi::TypeError::New(env, \"Expected spectrum object\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    \n    Napi::Object spectrum = info[0].As<Napi::Object>();\n    \n    // Crear datos para visualización\n    Napi::Object visualData = Napi::Object::New(env);\n    \n    if (spectrum.Has(\"magnitudes\") && spectrum.Get(\"magnitudes\").IsTypedArray()) {\n        Napi::Float32Array magnitudes = spectrum.Get(\"magnitudes\").As<Napi::Float32Array>();\n        \n        // Crear bins logarítmicos para visualización\n        const int visualBins = 64;\n        Napi::Float32Array visualMagnitudes = Napi::Float32Array::New(env, visualBins);\n        \n        // Mapeo logarítmico de bins FFT a bins de visualización\n        size_t fftBins = magnitudes.ElementLength();\n        \n        for (int i = 0; i < visualBins; ++i) {\n            // Mapeo logarítmico\n            double logIndex = std::pow(2.0, (double)i / visualBins * std::log2(fftBins));\n            size_t binIndex = std::min((size_t)logIndex, fftBins - 1);\n            \n            visualMagnitudes[i] = magnitudes[binIndex];\n        }\n        \n        visualData.Set(\"magnitudes\", visualMagnitudes);\n        \n        // Crear etiquetas de frecuencia\n        Napi::Array freqLabels = Napi::Array::New(env, visualBins);\n        for (int i = 0; i < visualBins; ++i) {\n            double freq = 20.0 * std::pow(1000.0, (double)i / (visualBins - 1)); // 20Hz a 20kHz\n            \n            std::string label;\n            if (freq < 1000) {\n                label = std::to_string((int)freq) + \"Hz\";\n            } else {\n                label = std::to_string((int)(freq / 1000)) + \"kHz\";\n            }\n            \n            freqLabels[i] = Napi::String::New(env, label);\n        }\n        visualData.Set(\"frequencyLabels\", freqLabels);\n    }\n    \n    return visualData;\n}\n\nNapi::Value CalculateAudioMetrics(const Napi::CallbackInfo& info) {\n    Napi::Env env = info.Env();\n    \n    if (info.Length() < 1 || !info[0].IsTypedArray()) {\n        Napi::TypeError::New(env, \"Expected Float32Array\").ThrowAsJavaScriptException();\n        return env.Null();\n    }\n    \n    Napi::Float32Array audioArray = info[0].As<Napi::Float32Array>();\n    \n    // Calcular métricas básicas\n    float rms = 0.0f;\n    float peak = 0.0f;\n    float zeroCrossings = 0.0f;\n    \n    for (size_t i = 0; i < audioArray.ElementLength(); ++i) {\n        float sample = audioArray[i];\n        \n        // RMS\n        rms += sample * sample;\n        \n        // Peak\n        peak = std::max(peak, std::abs(sample));\n        \n        // Zero crossings\n        if (i > 0) {\n            if ((audioArray[i-1] >= 0 && sample < 0) || (audioArray[i-1] < 0 && sample >= 0)) {\n                zeroCrossings += 1.0f;\n            }\n        }\n    }\n    \n    rms = std::sqrt(rms / audioArray.ElementLength());\n    zeroCrossings /= audioArray.ElementLength();\n    \n    // Crear objeto de métricas\n    Napi::Object metrics = Napi::Object::New(env);\n    metrics.Set(\"rms\", Napi::Number::New(env, rms));\n    metrics.Set(\"peak\", Napi::Number::New(env, peak));\n    metrics.Set(\"zeroCrossingRate\", Napi::Number::New(env, zeroCrossings));\n    \n    // Nivel en dB\n    double rmsDb = 20.0 * std::log10(std::max(rms, 1e-10));\n    double peakDb = 20.0 * std::log10(std::max(peak, 1e-10));\n    \n    metrics.Set(\"rmsDb\", Napi::Number::New(env, rmsDb));\n    metrics.Set(\"peakDb\", Napi::Number::New(env, peakDb));\n    \n    return metrics;\n}\n\nNapi::Object Init(Napi::Env env, Napi::Object exports) {\n    SpectrumAnalyzerWrapper::Init(env, exports);\n    \n    exports.Set(\"createSpectrumVisualizer\", Napi::Function::New(env, CreateSpectrumVisualizer));\n    exports.Set(\"calculateAudioMetrics\", Napi::Function::New(env, CalculateAudioMetrics));\n    \n    return exports;\n}\n\nNODE_API_MODULE(spectrum_analyzer, Init)"