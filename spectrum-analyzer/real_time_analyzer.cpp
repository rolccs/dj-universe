// Analizador de espectro en tiempo real para DJ Universe
// Optimizado para baja latencia y análisis profesional de audio

#include <vector>
#include <complex>
#include <memory>
#include <atomic>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <fftw3.h>

namespace DJUniverse {\n\nstruct SpectrumFrame {\n    std::vector<float> magnitudes;\n    std::vector<float> phases;\n    std::vector<float> frequencies;\n    double timestamp;\n    double peakFrequency;\n    double spectralCentroid;\n    double spectralRolloff;\n    double spectralFlux;\n    double rms;\n    bool isValid;\n};\n\nstruct BeatDetectionResult {\n    bool beatDetected;\n    double confidence;\n    double bpm;\n    double beatStrength;\n    std::vector<double> onsetTimes;\n};\n\nstruct FrequencyBands {\n    float sub_bass;      // 20-60 Hz\n    float bass;          // 60-250 Hz\n    float low_mids;      // 250-500 Hz\n    float mids;          // 500-2000 Hz\n    float high_mids;     // 2000-4000 Hz\n    float presence;      // 4000-6000 Hz\n    float brilliance;    // 6000-20000 Hz\n};\n\nclass RealTimeSpectrumAnalyzer {\npublic:\n    RealTimeSpectrumAnalyzer(int sampleRate = 44100, int fftSize = 2048, int hopSize = 512)\n        : m_sampleRate(sampleRate)\n        , m_fftSize(fftSize)\n        , m_hopSize(hopSize)\n        , m_isRunning(false)\n        , m_frameCounter(0)\n    {\n        initialize();\n    }\n    \n    ~RealTimeSpectrumAnalyzer() {\n        stop();\n        cleanup();\n    }\n    \n    bool initialize() {\n        try {\n            // Inicializar FFTW\n            setupFFTW();\n            \n            // Configurar ventanas\n            setupWindows();\n            \n            // Inicializar buffers\n            setupBuffers();\n            \n            // Configurar detectores\n            setupDetectors();\n            \n            m_isInitialized = true;\n            return true;\n            \n        } catch (const std::exception& e) {\n            return false;\n        }\n    }\n    \n    void start() {\n        if (!m_isInitialized || m_isRunning) {\n            return;\n        }\n        \n        m_isRunning = true;\n        \n        // Iniciar hilo de análisis\n        m_analysisThread = std::thread(&RealTimeSpectrumAnalyzer::analysisLoop, this);\n        \n        // Iniciar hilo de detección de beats\n        m_beatDetectionThread = std::thread(&RealTimeSpectrumAnalyzer::beatDetectionLoop, this);\n    }\n    \n    void stop() {\n        m_isRunning = false;\n        \n        m_audioCondition.notify_all();\n        m_spectrumCondition.notify_all();\n        \n        if (m_analysisThread.joinable()) {\n            m_analysisThread.join();\n        }\n        \n        if (m_beatDetectionThread.joinable()) {\n            m_beatDetectionThread.join();\n        }\n    }\n    \n    // Procesar audio en tiempo real\n    void processAudio(const float* audioData, size_t numSamples) {\n        if (!m_isRunning) {\n            return;\n        }\n        \n        std::lock_guard<std::mutex> lock(m_audioMutex);\n        \n        // Agregar datos al buffer circular\n        for (size_t i = 0; i < numSamples; ++i) {\n            m_audioBuffer[m_writeIndex] = audioData[i];\n            m_writeIndex = (m_writeIndex + 1) % m_audioBuffer.size();\n            \n            // Evitar overflow\n            if (m_writeIndex == m_readIndex) {\n                m_readIndex = (m_readIndex + 1) % m_audioBuffer.size();\n            }\n        }\n        \n        m_audioCondition.notify_one();\n    }\n    \n    // Obtener último frame de espectro\n    bool getLatestSpectrum(SpectrumFrame& frame) {\n        std::lock_guard<std::mutex> lock(m_spectrumMutex);\n        \n        if (m_spectrumQueue.empty()) {\n            return false;\n        }\n        \n        frame = m_spectrumQueue.back();\n        return true;\n    }\n    \n    // Obtener últimos resultados de detección de beats\n    bool getLatestBeatDetection(BeatDetectionResult& result) {\n        std::lock_guard<std::mutex> lock(m_beatMutex);\n        \n        if (m_beatQueue.empty()) {\n            return false;\n        }\n        \n        result = m_beatQueue.back();\n        return true;\n    }\n    \n    // Análisis de bandas de frecuencia\n    FrequencyBands analyzeFrequencyBands(const SpectrumFrame& frame) {\n        FrequencyBands bands = {0};\n        \n        if (!frame.isValid || frame.magnitudes.empty()) {\n            return bands;\n        }\n        \n        const float nyquist = m_sampleRate / 2.0f;\n        const size_t numBins = frame.magnitudes.size();\n        \n        // Definir rangos de frecuencia en bins\n        auto freqToBin = [=](float freq) {\n            return static_cast<size_t>((freq / nyquist) * numBins);\n        };\n        \n        size_t subBassEnd = freqToBin(60.0f);\n        size_t bassEnd = freqToBin(250.0f);\n        size_t lowMidsEnd = freqToBin(500.0f);\n        size_t midsEnd = freqToBin(2000.0f);\n        size_t highMidsEnd = freqToBin(4000.0f);\n        size_t presenceEnd = freqToBin(6000.0f);\n        \n        // Calcular energía en cada banda\n        bands.sub_bass = calculateBandEnergy(frame.magnitudes, freqToBin(20.0f), subBassEnd);\n        bands.bass = calculateBandEnergy(frame.magnitudes, subBassEnd, bassEnd);\n        bands.low_mids = calculateBandEnergy(frame.magnitudes, bassEnd, lowMidsEnd);\n        bands.mids = calculateBandEnergy(frame.magnitudes, lowMidsEnd, midsEnd);\n        bands.high_mids = calculateBandEnergy(frame.magnitudes, midsEnd, highMidsEnd);\n        bands.presence = calculateBandEnergy(frame.magnitudes, highMidsEnd, presenceEnd);\n        bands.brilliance = calculateBandEnergy(frame.magnitudes, presenceEnd, numBins);\n        \n        return bands;\n    }\n    \n    // Detectar clave/tonalidad usando análisis cromático\n    std::string detectMusicalKey(const std::vector<SpectrumFrame>& frames) {\n        if (frames.empty()) {\n            return \"Unknown\";\n        }\n        \n        // Calcular chroma vector promedio\n        std::vector<float> chromaVector = calculateChromaVector(frames);\n        \n        // Comparar con templates de tonalidades\n        return matchKeyTemplate(chromaVector);\n    }\n    \n    // Análisis de estabilidad de tempo\n    double analyzeTempoStability(const std::vector<BeatDetectionResult>& beatHistory) {\n        if (beatHistory.size() < 10) {\n            return 0.0;\n        }\n        \n        std::vector<double> bpmValues;\n        for (const auto& beat : beatHistory) {\n            if (beat.beatDetected && beat.bpm > 60 && beat.bpm < 200) {\n                bpmValues.push_back(beat.bpm);\n            }\n        }\n        \n        if (bpmValues.size() < 5) {\n            return 0.0;\n        }\n        \n        // Calcular varianza del BPM\n        double mean = std::accumulate(bpmValues.begin(), bpmValues.end(), 0.0) / bpmValues.size();\n        double variance = 0.0;\n        \n        for (double bpm : bpmValues) {\n            variance += (bpm - mean) * (bpm - mean);\n        }\n        variance /= bpmValues.size();\n        \n        double stdDev = std::sqrt(variance);\n        \n        // Convertir a puntuación de estabilidad (0-1)\n        double stability = std::max(0.0, 1.0 - (stdDev / 10.0));\n        return stability;\n    }\n    \nprivate:\n    // Configuración\n    int m_sampleRate;\n    int m_fftSize;\n    int m_hopSize;\n    bool m_isInitialized = false;\n    std::atomic<bool> m_isRunning;\n    \n    // FFTW objects\n    fftwf_plan m_fftPlan;\n    float* m_fftInput;\n    fftwf_complex* m_fftOutput;\n    \n    // Buffers\n    std::vector<float> m_audioBuffer;\n    std::vector<float> m_window;\n    std::vector<float> m_previousMagnitudes;\n    \n    // Índices de buffer circular\n    std::atomic<size_t> m_writeIndex{0};\n    std::atomic<size_t> m_readIndex{0};\n    \n    // Colas de resultados\n    std::queue<SpectrumFrame> m_spectrumQueue;\n    std::queue<BeatDetectionResult> m_beatQueue;\n    \n    // Sincronización\n    std::mutex m_audioMutex;\n    std::mutex m_spectrumMutex;\n    std::mutex m_beatMutex;\n    std::condition_variable m_audioCondition;\n    std::condition_variable m_spectrumCondition;\n    \n    // Hilos\n    std::thread m_analysisThread;\n    std::thread m_beatDetectionThread;\n    \n    // Detectores\n    std::unique_ptr<OnsetDetector> m_onsetDetector;\n    std::unique_ptr<BPMDetector> m_bpmDetector;\n    \n    // Contadores\n    std::atomic<uint64_t> m_frameCounter;\n    \n    void setupFFTW() {\n        m_fftInput = fftwf_alloc_real(m_fftSize);\n        m_fftOutput = fftwf_alloc_complex(m_fftSize / 2 + 1);\n        \n        m_fftPlan = fftwf_plan_dft_r2c_1d(\n            m_fftSize,\n            m_fftInput,\n            m_fftOutput,\n            FFTW_MEASURE\n        );\n        \n        if (!m_fftPlan) {\n            throw std::runtime_error(\"Failed to create FFTW plan\");\n        }\n    }\n    \n    void setupWindows() {\n        // Ventana Hanning\n        m_window.resize(m_fftSize);\n        for (int i = 0; i < m_fftSize; ++i) {\n            m_window[i] = 0.5f * (1.0f - std::cos(2.0f * M_PI * i / (m_fftSize - 1)));\n        }\n    }\n    \n    void setupBuffers() {\n        // Buffer circular para audio\n        m_audioBuffer.resize(m_fftSize * 4); // 4x para evitar overrun\n        std::fill(m_audioBuffer.begin(), m_audioBuffer.end(), 0.0f);\n        \n        // Buffer para magnitudes previas (para spectral flux)\n        m_previousMagnitudes.resize(m_fftSize / 2 + 1, 0.0f);\n    }\n    \n    void setupDetectors() {\n        m_onsetDetector = std::make_unique<OnsetDetector>(m_sampleRate, m_fftSize);\n        m_bpmDetector = std::make_unique<BPMDetector>(m_sampleRate);\n    }\n    \n    void cleanup() {\n        if (m_fftPlan) {\n            fftwf_destroy_plan(m_fftPlan);\n        }\n        if (m_fftInput) {\n            fftwf_free(m_fftInput);\n        }\n        if (m_fftOutput) {\n            fftwf_free(m_fftOutput);\n        }\n    }\n    \n    void analysisLoop() {\n        std::vector<float> frameBuffer(m_fftSize);\n        \n        while (m_isRunning) {\n            // Esperar por datos de audio\n            std::unique_lock<std::mutex> lock(m_audioMutex);\n            m_audioCondition.wait(lock, [this] {\n                size_t available = (m_writeIndex + m_audioBuffer.size() - m_readIndex) % m_audioBuffer.size();\n                return !m_isRunning || available >= m_fftSize;\n            });\n            \n            if (!m_isRunning) {\n                break;\n            }\n            \n            // Leer frame de audio\n            if (!readAudioFrame(frameBuffer)) {\n                continue;\n            }\n            \n            lock.unlock();\n            \n            // Procesar frame\n            SpectrumFrame spectrum = processFrame(frameBuffer);\n            \n            // Almacenar resultado\n            {\n                std::lock_guard<std::mutex> spectrumLock(m_spectrumMutex);\n                m_spectrumQueue.push(spectrum);\n                \n                // Mantener cola de tamaño limitado\n                while (m_spectrumQueue.size() > 100) {\n                    m_spectrumQueue.pop();\n                }\n            }\n            \n            m_spectrumCondition.notify_one();\n        }\n    }\n    \n    bool readAudioFrame(std::vector<float>& frameBuffer) {\n        size_t available = (m_writeIndex + m_audioBuffer.size() - m_readIndex) % m_audioBuffer.size();\n        \n        if (available < m_fftSize) {\n            return false;\n        }\n        \n        for (int i = 0; i < m_fftSize; ++i) {\n            frameBuffer[i] = m_audioBuffer[m_readIndex];\n            m_readIndex = (m_readIndex + 1) % m_audioBuffer.size();\n        }\n        \n        return true;\n    }\n    \n    SpectrumFrame processFrame(const std::vector<float>& audioFrame) {\n        SpectrumFrame frame;\n        frame.timestamp = std::chrono::duration<double>(\n            std::chrono::high_resolution_clock::now().time_since_epoch()\n        ).count();\n        \n        // Aplicar ventana\n        for (int i = 0; i < m_fftSize; ++i) {\n            m_fftInput[i] = audioFrame[i] * m_window[i];\n        }\n        \n        // Ejecutar FFT\n        fftwf_execute(m_fftPlan);\n        \n        // Calcular magnitudes y fases\n        int numBins = m_fftSize / 2 + 1;\n        frame.magnitudes.resize(numBins);\n        frame.phases.resize(numBins);\n        frame.frequencies.resize(numBins);\n        \n        float maxMagnitude = 0.0f;\n        size_t peakBin = 0;\n        float spectralSum = 0.0f;\n        float weightedSum = 0.0f;\n        \n        for (int i = 0; i < numBins; ++i) {\n            float real = m_fftOutput[i][0];\n            float imag = m_fftOutput[i][1];\n            \n            float magnitude = std::sqrt(real * real + imag * imag);\n            frame.magnitudes[i] = magnitude;\n            frame.phases[i] = std::atan2(imag, real);\n            frame.frequencies[i] = (float)i * m_sampleRate / m_fftSize;\n            \n            // Encontrar pico\n            if (magnitude > maxMagnitude) {\n                maxMagnitude = magnitude;\n                peakBin = i;\n            }\n            \n            // Para centroide espectral\n            spectralSum += magnitude;\n            weightedSum += magnitude * frame.frequencies[i];\n        }\n        \n        // Calcular características espectrales\n        frame.peakFrequency = frame.frequencies[peakBin];\n        frame.spectralCentroid = (spectralSum > 0) ? weightedSum / spectralSum : 0.0;\n        frame.spectralRolloff = calculateSpectralRolloff(frame.magnitudes, frame.frequencies);\n        frame.spectralFlux = calculateSpectralFlux(frame.magnitudes);\n        frame.rms = calculateRMS(audioFrame);\n        \n        frame.isValid = true;\n        m_frameCounter++;\n        \n        return frame;\n    }\n    \n    void beatDetectionLoop() {\n        std::vector<SpectrumFrame> frameHistory;\n        \n        while (m_isRunning) {\n            SpectrumFrame frame;\n            \n            // Esperar por nuevo frame de espectro\n            {\n                std::unique_lock<std::mutex> lock(m_spectrumMutex);\n                m_spectrumCondition.wait(lock, [this] {\n                    return !m_isRunning || !m_spectrumQueue.empty();\n                });\n                \n                if (!m_isRunning) {\n                    break;\n                }\n                \n                if (m_spectrumQueue.empty()) {\n                    continue;\n                }\n                \n                frame = m_spectrumQueue.front();\n            }\n            \n            frameHistory.push_back(frame);\n            \n            // Mantener historial limitado\n            if (frameHistory.size() > 200) {\n                frameHistory.erase(frameHistory.begin());\n            }\n            \n            // Detectar beats si tenemos suficiente historial\n            if (frameHistory.size() >= 10) {\n                BeatDetectionResult beatResult = detectBeat(frameHistory);\n                \n                {\n                    std::lock_guard<std::mutex> lock(m_beatMutex);\n                    m_beatQueue.push(beatResult);\n                    \n                    // Mantener cola limitada\n                    while (m_beatQueue.size() > 50) {\n                        m_beatQueue.pop();\n                    }\n                }\n            }\n        }\n    }\n    \n    BeatDetectionResult detectBeat(const std::vector<SpectrumFrame>& frameHistory) {\n        BeatDetectionResult result;\n        result.beatDetected = false;\n        result.confidence = 0.0;\n        result.bpm = 0.0;\n        result.beatStrength = 0.0;\n        \n        if (frameHistory.size() < 10) {\n            return result;\n        }\n        \n        // Usar detección de onset basada en spectral flux\n        std::vector<float> onsetStrength;\n        for (const auto& frame : frameHistory) {\n            onsetStrength.push_back(frame.spectralFlux);\n        }\n        \n        // Detectar picos en onset strength\n        std::vector<size_t> onsetIndices = m_onsetDetector->detectOnsets(onsetStrength);\n        \n        // Convertir índices a tiempos\n        result.onsetTimes.clear();\n        for (size_t idx : onsetIndices) {\n            if (idx < frameHistory.size()) {\n                result.onsetTimes.push_back(frameHistory[idx].timestamp);\n            }\n        }\n        \n        // Detectar BPM si tenemos suficientes onsets\n        if (result.onsetTimes.size() >= 4) {\n            auto bpmResult = m_bpmDetector->detectBPM(result.onsetTimes);\n            result.bpm = bpmResult.bpm;\n            result.confidence = bpmResult.confidence;\n            result.beatDetected = (result.confidence > 0.5);\n        }\n        \n        // Calcular fuerza del beat actual\n        if (!frameHistory.empty()) {\n            const auto& currentFrame = frameHistory.back();\n            result.beatStrength = currentFrame.spectralFlux;\n        }\n        \n        return result;\n    }\n    \n    float calculateBandEnergy(const std::vector<float>& magnitudes, size_t startBin, size_t endBin) {\n        float energy = 0.0f;\n        endBin = std::min(endBin, magnitudes.size());\n        \n        for (size_t i = startBin; i < endBin; ++i) {\n            energy += magnitudes[i] * magnitudes[i];\n        }\n        \n        return std::sqrt(energy / (endBin - startBin));\n    }\n    \n    float calculateSpectralRolloff(const std::vector<float>& magnitudes, const std::vector<float>& frequencies) {\n        float totalEnergy = 0.0f;\n        for (float mag : magnitudes) {\n            totalEnergy += mag * mag;\n        }\n        \n        float threshold = totalEnergy * 0.85f; // 85% rolloff\n        float cumulativeEnergy = 0.0f;\n        \n        for (size_t i = 0; i < magnitudes.size(); ++i) {\n            cumulativeEnergy += magnitudes[i] * magnitudes[i];\n            if (cumulativeEnergy >= threshold) {\n                return frequencies[i];\n            }\n        }\n        \n        return frequencies.back();\n    }\n    \n    float calculateSpectralFlux(const std::vector<float>& magnitudes) {\n        if (m_previousMagnitudes.size() != magnitudes.size()) {\n            m_previousMagnitudes = magnitudes;\n            return 0.0f;\n        }\n        \n        float flux = 0.0f;\n        for (size_t i = 0; i < magnitudes.size(); ++i) {\n            float diff = magnitudes[i] - m_previousMagnitudes[i];\n            flux += std::max(0.0f, diff); // Solo incrementos positivos\n        }\n        \n        m_previousMagnitudes = magnitudes;\n        return flux;\n    }\n    \n    float calculateRMS(const std::vector<float>& audioFrame) {\n        float sum = 0.0f;\n        for (float sample : audioFrame) {\n            sum += sample * sample;\n        }\n        return std::sqrt(sum / audioFrame.size());\n    }\n    \n    std::vector<float> calculateChromaVector(const std::vector<SpectrumFrame>& frames) {\n        std::vector<float> chroma(12, 0.0f);\n        \n        for (const auto& frame : frames) {\n            for (size_t i = 0; i < frame.frequencies.size(); ++i) {\n                float freq = frame.frequencies[i];\n                float magnitude = frame.magnitudes[i];\n                \n                if (freq > 80.0f && freq < 2000.0f) {\n                    // Convertir frecuencia a clase de pitch\n                    int pitchClass = frequencyToPitchClass(freq);\n                    if (pitchClass >= 0 && pitchClass < 12) {\n                        chroma[pitchClass] += magnitude;\n                    }\n                }\n            }\n        }\n        \n        // Normalizar\n        float sum = std::accumulate(chroma.begin(), chroma.end(), 0.0f);\n        if (sum > 0.0f) {\n            for (float& value : chroma) {\n                value /= sum;\n            }\n        }\n        \n        return chroma;\n    }\n    \n    int frequencyToPitchClass(float frequency) {\n        if (frequency <= 0) return -1;\n        \n        // Convertir a número MIDI\n        float midiNote = 69.0f + 12.0f * std::log2(frequency / 440.0f);\n        \n        // Obtener clase de pitch (0-11)\n        int pitchClass = static_cast<int>(std::round(midiNote)) % 12;\n        if (pitchClass < 0) pitchClass += 12;\n        \n        return pitchClass;\n    }\n    \n    std::string matchKeyTemplate(const std::vector<float>& chromaVector) {\n        // Templates simplificados para tonalidades mayores\n        std::vector<std::string> keyNames = {\n            \"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"\n        };\n        \n        // Perfil de tonalidad mayor (Krumhansl-Schmuckler)\n        std::vector<float> majorProfile = {\n            6.35f, 2.23f, 3.48f, 2.33f, 4.38f, 4.09f,\n            2.52f, 5.19f, 2.39f, 3.66f, 2.29f, 2.88f\n        };\n        \n        float bestCorrelation = -1.0f;\n        int bestKey = 0;\n        \n        // Probar todas las rotaciones del perfil\n        for (int key = 0; key < 12; ++key) {\n            float correlation = 0.0f;\n            for (int i = 0; i < 12; ++i) {\n                int profileIndex = (i - key + 12) % 12;\n                correlation += chromaVector[i] * majorProfile[profileIndex];\n            }\n            \n            if (correlation > bestCorrelation) {\n                bestCorrelation = correlation;\n                bestKey = key;\n            }\n        }\n        \n        return bestCorrelation > 0.5f ? keyNames[bestKey] : \"Unknown\";\n    }\n};\n\n// Clases auxiliares para detección\n\nclass OnsetDetector {\npublic:\n    OnsetDetector(int sampleRate, int fftSize) \n        : m_sampleRate(sampleRate), m_fftSize(fftSize) {}\n    \n    std::vector<size_t> detectOnsets(const std::vector<float>& onsetStrength) {\n        std::vector<size_t> onsets;\n        \n        if (onsetStrength.size() < 5) {\n            return onsets;\n        }\n        \n        // Detección de picos simple con umbral adaptativo\n        float mean = std::accumulate(onsetStrength.begin(), onsetStrength.end(), 0.0f) / onsetStrength.size();\n        float threshold = mean * 1.5f; // Umbral adaptativo\n        \n        for (size_t i = 2; i < onsetStrength.size() - 2; ++i) {\n            if (onsetStrength[i] > threshold &&\n                onsetStrength[i] > onsetStrength[i-1] &&\n                onsetStrength[i] > onsetStrength[i+1] &&\n                onsetStrength[i] > onsetStrength[i-2] &&\n                onsetStrength[i] > onsetStrength[i+2]) {\n                \n                onsets.push_back(i);\n            }\n        }\n        \n        return onsets;\n    }\n    \nprivate:\n    int m_sampleRate;\n    int m_fftSize;\n};\n\nstruct BPMResult {\n    double bpm;\n    double confidence;\n};\n\nclass BPMDetector {\npublic:\n    BPMDetector(int sampleRate) : m_sampleRate(sampleRate) {}\n    \n    BPMResult detectBPM(const std::vector<double>& onsetTimes) {\n        BPMResult result = {0.0, 0.0};\n        \n        if (onsetTimes.size() < 4) {\n            return result;\n        }\n        \n        // Calcular intervalos entre onsets\n        std::vector<double> intervals;\n        for (size_t i = 1; i < onsetTimes.size(); ++i) {\n            double interval = onsetTimes[i] - onsetTimes[i-1];\n            if (interval > 0.3 && interval < 2.0) { // Filtrar intervalos razonables\n                intervals.push_back(interval);\n            }\n        }\n        \n        if (intervals.empty()) {\n            return result;\n        }\n        \n        // Encontrar intervalo más común\n        std::sort(intervals.begin(), intervals.end());\n        double medianInterval = intervals[intervals.size() / 2];\n        \n        // Convertir a BPM\n        result.bpm = 60.0 / medianInterval;\n        \n        // Calcular confianza basada en consistencia\n        int consistentIntervals = 0;\n        double tolerance = medianInterval * 0.1; // 10% tolerancia\n        \n        for (double interval : intervals) {\n            if (std::abs(interval - medianInterval) < tolerance) {\n                consistentIntervals++;\n            }\n        }\n        \n        result.confidence = static_cast<double>(consistentIntervals) / intervals.size();\n        \n        return result;\n    }\n    \nprivate:\n    int m_sampleRate;\n};\n\n} // namespace DJUniverse"